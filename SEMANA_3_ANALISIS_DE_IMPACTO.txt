═══════════════════════════════════════════════════════════════════════════════
                    SEMANA 3 - ANÁLISIS DE IMPACTO
                      CAMBIOS DE PRIORIDAD MEDIA
═══════════════════════════════════════════════════════════════════════════════

FECHA: 18 de diciembre de 2025
ARCHIVOS ANALIZADOS: 3 principales (reportes_avanzados_logic.py, logic.py, importador_logic.py)
COLUMNAS AFECTADAS: 2 (fecha→fecha_entrada, presupuesto→presupuesto_inicial)
REFERENCIAS ENCONTRADAS: 11 ubicaciones + mejora de cálculos

═══════════════════════════════════════════════════════════════════════════════
                            RESUMEN EJECUTIVO
═══════════════════════════════════════════════════════════════════════════════

CAMBIO #1: fecha → fecha_entrada en reportes
   • Archivo: reportes_avanzados_logic.py
   • Ubicaciones: 4 queries SQL
   • Impacto: ALTO - Afecta exportaciones Excel/PDF y análisis de ganancias

CAMBIO #2: presupuesto → presupuesto_inicial en reportes
   • Archivo: reportes_avanzados_logic.py
   • Ubicaciones: 4 queries SQL
   • Impacto: ALTO - Afecta cálculos de ventas, márgenes y comparativos

CAMBIO #3: rut → cedula en módulos secundarios
   • Archivos: logic.py, importador_logic.py
   • Ubicaciones: 9 queries SQL
   • Impacto: MEDIO - Afecta búsqueda y gestión de clientes

CAMBIO #4 (MEJORA CRÍTICA): Cálculo de utilidad_bruta
   • Archivo: reportes_avanzados_logic.py
   • Problema: Cálculo incorrecto de ganancia_bruta (solo resta mano_de_obra)
   • Solución: Usar utilidad_bruta calculada por trigger en tabla ordenes
   • Impacto: CRÍTICO - Corrige reportes financieros

NOTA IMPORTANTE: La columna "rut" en tabla clientes NO FUE RENOMBRADA en la estructura
de la base de datos (aún se llama "rut", no "cedula"). Este análisis se enfoca en
renombres que SÍ ocurrieron en la nueva estructura.

═══════════════════════════════════════════════════════════════════════════════
                        DETALLE POR ARCHIVO
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────────┐
│ ARCHIVO: servitec_manager/reportes_avanzados_logic.py                      │
│ ESTADO: REQUIERE 8 CAMBIOS + 1 MEJORA CRÍTICA                              │
└─────────────────────────────────────────────────────────────────────────────┘

FUNCIÓN: OBTENER_REPORTE_VENTAS_PERÍODO()
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Línea 26
PROPÓSITO: Reporte completo de ventas en período (base para exportaciones)

CÓDIGO ACTUAL:
    ventas = self.db.fetch_all(
        "SELECT id, cliente_id, presupuesto, abono, estado, fecha 
         FROM ordenes 
         WHERE fecha BETWEEN ? AND ? 
         ORDER BY fecha DESC",
        (fecha_inicio, fecha_fin)
    )

CÓDIGO CORREGIDO:
    ventas = self.db.fetch_all(
        "SELECT id, cliente_id, presupuesto_inicial, abono, estado, fecha_entrada 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? 
         ORDER BY fecha_entrada DESC",
        (fecha_inicio, fecha_fin)
    )

CAMBIOS:
    • ✅ presupuesto → presupuesto_inicial (SELECT)
    • ✅ fecha → fecha_entrada (3 veces: SELECT, WHERE, ORDER BY)

IMPACTO:
    • Query usado en: Exportaciones Excel, reportes PDF, análisis comparativos
    • Índice de acceso: v[2] sigue siendo presupuesto (mismo índice)
    • Crítico: Línea 30 accede a v[2] - no requiere cambio en código Python
    • Función dependiente: OBTENER_COMPARATIVA_PERÍODOS() usa este query


FUNCIÓN: OBTENER_REPORTE_VENTAS_DIARIAS()
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Línea 62
PROPÓSITO: Desglose de ventas por día para gráficos

CÓDIGO ACTUAL:
    ventas = self.db.fetch_all(
        "SELECT DATE(fecha) as fecha, SUM(presupuesto) as total, COUNT(*) as cantidad 
         FROM ordenes 
         WHERE fecha BETWEEN ? AND ? 
         GROUP BY DATE(fecha) 
         ORDER BY fecha DESC",
        (fecha_inicio, fecha_fin)
    )

CÓDIGO CORREGIDO:
    ventas = self.db.fetch_all(
        "SELECT DATE(fecha_entrada) as fecha, SUM(presupuesto_inicial) as total, COUNT(*) as cantidad 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? 
         GROUP BY DATE(fecha_entrada) 
         ORDER BY fecha DESC",
        (fecha_inicio, fecha_fin)
    )

CAMBIOS:
    • ✅ fecha → fecha_entrada (4 veces: DATE(), WHERE, GROUP BY, alias conservado)
    • ✅ presupuesto → presupuesto_inicial (SUM())
    • ⚠️ IMPORTANTE: Alias "as fecha" se mantiene (línea 69 accede a venta[0])

IMPACTO:
    • Query usado en: Gráficos de ventas diarias, dashboards
    • Formato de salida: {"fecha": "YYYY-MM-DD", "total_ventas": X, ...}
    • Código Python NO requiere cambios (alias preservado)


FUNCIÓN: OBTENER_REPORTE_GANANCIAS()
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Línea 116
PROPÓSITO: Análisis de ganancias y márgenes (REPORTE FINANCIERO CRÍTICO)

CÓDIGO ACTUAL:
    ventas = self.db.fetch_one(
        "SELECT SUM(presupuesto) as total 
         FROM ordenes 
         WHERE fecha BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )

CÓDIGO CORREGIDO:
    ventas = self.db.fetch_one(
        "SELECT SUM(presupuesto_inicial) as total 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )

CAMBIOS:
    • ✅ presupuesto → presupuesto_inicial (SUM())
    • ✅ fecha → fecha_entrada (WHERE)

IMPACTO:
    • Query usado en: Reportes financieros, cálculo de márgenes
    • Variable: total_ventas (línea 118)
    • Usado en cálculo de: margen_bruto, margen_neto


⚠️⚠️⚠️ PROBLEMA CRÍTICO ENCONTRADO: Cálculo de ganancia_bruta INCORRECTO
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Líneas 140-142
PROBLEMA DETECTADO:

CÓDIGO ACTUAL (INCORRECTO):
    ganancia_bruta = total_ventas - total_mo  # Solo resta mano de obra
    margen_bruto = (ganancia_bruta / total_ventas * 100) if total_ventas > 0 else 0

ANÁLISIS DEL PROBLEMA:
    • ganancia_bruta = total_ventas - total_mo
    • Falta restar: costos de repuestos, costos de servicios, costos de envío
    • La tabla ordenes ahora tiene utilidad_bruta calculada por TRIGGER
    • Trigger usa fórmula: 
      utilidad_bruta = total_a_cobrar - costo_total_repuestos - costo_total_servicios

CÓDIGO CORREGIDO (OPCIÓN 1 - Usar trigger):
    # Obtener utilidad_bruta calculada por trigger (ya incluye todos los costos)
    utilidad = self.db.fetch_one(
        "SELECT SUM(utilidad_bruta) as total 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? AND fecha_cierre IS NOT NULL",
        (fecha_inicio, fecha_fin)
    )
    ganancia_bruta = utilidad[0] if utilidad[0] else 0
    margen_bruto = (ganancia_bruta / total_ventas * 100) if total_ventas > 0 else 0

CÓDIGO CORREGIDO (OPCIÓN 2 - Calcular manual con nuevos campos):
    # Obtener costos totales de repuestos y servicios
    costos = self.db.fetch_one(
        "SELECT SUM(costo_total_repuestos), SUM(costo_total_servicios) 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )
    costo_repuestos = costos[0] if costos[0] else 0
    costo_servicios = costos[1] if costos[1] else 0
    
    ganancia_bruta = total_ventas - costo_repuestos - costo_servicios - total_mo

RECOMENDACIÓN: Usar OPCIÓN 1 (trigger)
    • Ventaja: Consistente con cálculo del trigger (única fuente de verdad)
    • Ventaja: Más simple y rápido
    • Ventaja: Incluye automáticamente descuentos, envíos, etc.

IMPACTO SI NO SE CORRIGE:
    ⚠️⚠️⚠️ CRÍTICO - Reportes financieros mostrarán ganancias INFLADAS
    • ganancia_bruta será MAYOR de lo real (falta restar costos)
    • margen_bruto será INCORRECTO (% demasiado alto)
    • Decisiones gerenciales basadas en datos erróneos


FUNCIÓN: OBTENER_CLIENTES_TOP()
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Línea 225
PROPÓSITO: Clientes con más compras/gasto (Top 10)

CÓDIGO ACTUAL:
    clientes = self.db.fetch_all(
        "SELECT c.nombre, COUNT(o.id) as cantidad, SUM(o.presupuesto) as total 
         FROM clientes c 
         LEFT JOIN ordenes o ON c.id = o.cliente_id 
         GROUP BY c.id 
         ORDER BY total DESC 
         LIMIT ?",
        (límite,)
    )

CÓDIGO CORREGIDO:
    clientes = self.db.fetch_all(
        "SELECT c.nombre, COUNT(o.id) as cantidad, SUM(o.presupuesto_inicial) as total 
         FROM clientes c 
         LEFT JOIN ordenes o ON c.id = o.cliente_id 
         GROUP BY c.id 
         ORDER BY total DESC 
         LIMIT ?",
        (límite,)
    )

CAMBIOS:
    • ✅ o.presupuesto → o.presupuesto_inicial (SUM())

IMPACTO:
    • Query usado en: Dashboard gerencial, reportes de clientes
    • Formato de salida: [{"cliente": "X", "cantidad_ordenes": N, "gasto_total": $}]
    • Código Python NO requiere cambios


FUNCIÓN: _CALCULAR_COSTOS_PRODUCTOS() (HELPER PRIVADA)
─────────────────────────────────────────────────────────────────────────────
UBICACIÓN: Línea 171
PROPÓSITO: Calcular costo de productos vendidos (para POS)
ESTADO: ✅ NO REQUIERE CAMBIOS

ANÁLISIS:
    Query actual:
    "SELECT COALESCE(SUM(costo_unitario * cantidad), 0) 
     FROM detalles_ventas 
     WHERE fecha BETWEEN ? AND ?"

    • Tabla: detalles_ventas (ventas del POS, NO órdenes de reparación)
    • Campo fecha: En tabla ventas SÍ existe (no cambió a fecha_entrada)
    • Tabla ventas NO es tabla ordenes (diferentes estructuras)

CONCLUSIÓN: NO TOCAR (query correcto para su propósito)


RESUMEN reportes_avanzados_logic.py:
─────────────────────────────────────────────────────────────────────────────
CAMBIOS REQUERIDOS: 8 ocurrencias + 1 mejora crítica
    • 4x "fecha" → "fecha_entrada" (en queries de ordenes)
    • 4x "presupuesto" → "presupuesto_inicial" (en queries de ordenes)
    • 1x Reescribir cálculo de ganancia_bruta (usar utilidad_bruta de trigger)

FUNCIONES AFECTADAS: 4 + 1 mejora
    1. OBTENER_REPORTE_VENTAS_PERÍODO() - Reporte base
    2. OBTENER_REPORTE_VENTAS_DIARIAS() - Gráficos diarios
    3. OBTENER_REPORTE_GANANCIAS() - Análisis financiero
    4. OBTENER_CLIENTES_TOP() - Ranking de clientes
    5. ⚠️ MEJORA: Cálculo de ganancia_bruta (CRÍTICO)

LÍNEAS DE CÓDIGO AFECTADAS: 4 queries + 1 bloque de cálculo

CRITICIDAD: ⚠️⚠️ ALTA + ⚠️⚠️⚠️ CRÍTICA (ganancia_bruta)


┌─────────────────────────────────────────────────────────────────────────────┐
│ ARCHIVO: servitec_manager/logic.py (CLIENTES)                              │
│ ESTADO: ⚠️ ANÁLISIS ESPECIAL - "rut" NO CAMBIÓ EN BD                       │
└─────────────────────────────────────────────────────────────────────────────┘

HALLAZGO IMPORTANTE: La columna "rut" en tabla "clientes" NO FUE RENOMBRADA
─────────────────────────────────────────────────────────────────────────────

ANÁLISIS DE ESQUEMA:
    • Estructura antigua (database.py): CREATE TABLE clientes (... rut TEXT UNIQUE ...)
    • Estructura nueva (database_schema_optimized.sql): ¿rut o cedula?
    • grep_search muestra: Todos los queries actuales usan "rut"
    • Evidencia: 79 referencias a "rut" en todo el codebase

VERIFICACIÓN NECESARIA:
    ¿La columna en la tabla clientes se llama "rut" o "cedula"?

ESCENARIO A: Si columna es "rut" (NO cambió)
    → NO SE REQUIEREN CAMBIOS en logic.py, importador_logic.py
    → Mantener queries actuales: WHERE rut = ?, INSERT clientes (rut, ...)

ESCENARIO B: Si columna es "cedula" (cambió)
    → REQUERIDOS 9 cambios en logic.py (3 funciones)
    → REQUERIDOS 4 cambios en importador_logic.py
    → Alto impacto: Búsqueda de clientes, gestión de usuarios, importaciones

RECOMENDACIÓN: VERIFICAR ESQUEMA ACTUAL
    Ejecutar: SELECT * FROM clientes LIMIT 1 en SERVITEC_TEST_OPTIMIZED.DB
    O leer: database_schema_optimized.sql completo

FUNCIONES POTENCIALMENTE AFECTADAS (SI cambió a cedula):
─────────────────────────────────────────────────────────────────────────────

logic.py - AGREGAR_CLIENTE() (Línea 31):
    ACTUAL:
        "INSERT INTO clientes (rut, nombre, telefono, email) VALUES (?, ?, ?, ?)"
    
    SI CAMBIÓ:
        "INSERT INTO clientes (cedula, nombre, telefono, email) VALUES (?, ?, ?, ?)"

logic.py - ACTUALIZAR_CLIENTE() (Línea 35):
    ACTUAL:
        "UPDATE clientes SET nombre = ?, telefono = ?, email = ? WHERE rut = ?"
    
    SI CAMBIÓ:
        "UPDATE clientes SET nombre = ?, telefono = ?, email = ? WHERE cedula = ?"

logic.py - OBTENER_CLIENTE() (Línea 38):
    ACTUAL:
        "SELECT * FROM clientes WHERE rut = ?"
    
    SI CAMBIÓ:
        "SELECT * FROM clientes WHERE cedula = ?"

logic.py - BUSCAR_CLIENTES() (Línea 41):
    ACTUAL:
        "SELECT * FROM clientes WHERE NOMBRE LIKE ? OR REPLACE(REPLACE(rut, '.', ''), '-', '') LIKE ?"
    
    SI CAMBIÓ:
        "SELECT * FROM clientes WHERE NOMBRE LIKE ? OR REPLACE(REPLACE(cedula, '.', ''), '-', '') LIKE ?"

importador_logic.py - IMPORTAR_CLIENTES() (Líneas 124, 131, 136):
    ACTUAL (3 queries):
        "SELECT id FROM clientes WHERE rut = ?"
        "UPDATE clientes SET ... WHERE rut=?"
        "INSERT INTO clientes (rut, ...) VALUES (...)"
    
    SI CAMBIÓ (3 queries):
        "SELECT id FROM clientes WHERE cedula = ?"
        "UPDATE clientes SET ... WHERE cedula=?"
        "INSERT INTO clientes (cedula, ...) VALUES (...)"

importador_logic.py - IMPORTAR_ÓRDENES() (Línea 185):
    ACTUAL:
        "SELECT id FROM clientes WHERE rut = ? OR nombre LIKE ?"
    
    SI CAMBIÓ:
        "SELECT id FROM clientes WHERE cedula = ? OR nombre LIKE ?"

IMPACTO SI cambió a "cedula" Y NO SE CORRIGE:
    ⚠️⚠️⚠️ BLOQUEANTE TOTAL
    • Error: "no such column: rut"
    • Módulos afectados: Gestión de clientes, importaciones, recepción
    • Funcionalidades rotas: Buscar cliente, crear cliente, editar cliente, importar Excel
    • UI afectada: Recepción, admin, importador


ESTADO ACTUAL: ⚠️ REQUIERE VERIFICACIÓN DE ESQUEMA
    Paso 1: Verificar si columna es "rut" o "cedula"
    Paso 2: Si es "cedula", aplicar 9 cambios (4 logic.py + 5 importador_logic.py)
    Paso 3: Si es "rut", NO TOCAR (queries correctos)


┌─────────────────────────────────────────────────────────────────────────────┐
│ ARCHIVO: servitec_manager/importador_logic.py                              │
│ ESTADO: PENDIENTE VERIFICACIÓN (dependiente de esquema clientes)           │
└─────────────────────────────────────────────────────────────────────────────┘

Ver análisis en sección logic.py arriba.

RESUMEN:
    • 5 ubicaciones con referencias a "rut"
    • SI columna cambió a "cedula": Aplicar cambios
    • SI columna sigue siendo "rut": NO TOCAR


═══════════════════════════════════════════════════════════════════════════════
                    VERIFICACIÓN DE ESQUEMA REQUERIDA
═══════════════════════════════════════════════════════════════════════════════

PREGUNTA CRÍTICA: ¿La columna en tabla clientes se llama "rut" o "cedula"?

MÉTODO DE VERIFICACIÓN:
    1. Leer database_schema_optimized.sql líneas de CREATE TABLE clientes
    2. O ejecutar: PRAGMA table_info(clientes) en BD de prueba
    3. O revisar documentación de migración FASE 2

DECISIÓN BASADA EN RESULTADO:
    • Si columna = "rut" → NO CAMBIAR logic.py ni importador_logic.py
    • Si columna = "cedula" → APLICAR 9 cambios (rut→cedula)

IMPACTO EN SEMANA 3:
    • SI no cambió: SEMANA 3 tiene 8 cambios (solo reportes_avanzados_logic.py)
    • SI cambió: SEMANA 3 tiene 17 cambios (reportes + logic + importador)


═══════════════════════════════════════════════════════════════════════════════
                        ANÁLISIS DE UTILIDAD BRUTA
═══════════════════════════════════════════════════════════════════════════════

PROBLEMA DETECTADO: Cálculo incorrecto en OBTENER_REPORTE_GANANCIAS()
─────────────────────────────────────────────────────────────────────────────

FÓRMULA ACTUAL (INCORRECTA):
    ganancia_bruta = total_ventas - total_mo

PROBLEMA:
    • Solo resta mano de obra (comisiones técnicos)
    • NO resta: costo_total_repuestos, costo_total_servicios
    • Resultado: Ganancia bruta INFLADA (mayor de lo real)

FÓRMULA CORRECTA (según trigger tr_ordenes_update_utilidad_bruta):
    utilidad_bruta = total_a_cobrar - costo_total_repuestos - costo_total_servicios

DIFERENCIAS:
    • Trigger usa: total_a_cobrar (después de descuentos)
    • Código usa: total_ventas (presupuesto sin descuentos)
    • Trigger resta: repuestos + servicios
    • Código resta: solo mano de obra (comisiones)

SOLUCIÓN PROPUESTA: Usar utilidad_bruta de trigger
─────────────────────────────────────────────────────────────────────────────

CÓDIGO CORREGIDO:
    # Obtener utilidad bruta calculada por trigger
    utilidad = self.db.fetch_one(
        "SELECT COALESCE(SUM(utilidad_bruta), 0) as total 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? 
           AND fecha_cierre IS NOT NULL",  # Solo órdenes cerradas
        (fecha_inicio, fecha_fin)
    )
    ganancia_bruta = utilidad[0] if utilidad[0] else 0
    
    # Mantener cálculo de ganancia_neta (resta gastos operacionales)
    ganancia_neta = ganancia_bruta - total_gastos
    
    # Recalcular márgenes
    margen_bruto = (ganancia_bruta / total_ventas * 100) if total_ventas > 0 else 0
    margen_neto = (ganancia_neta / total_ventas * 100) if total_ventas > 0 else 0

VENTAJAS:
    ✅ Consistente con trigger (única fuente de verdad)
    ✅ Incluye todos los costos (repuestos, servicios, envío)
    ✅ Respeta descuentos aplicados
    ✅ Filtra solo órdenes cerradas (con utilidad_bruta calculada)
    ✅ Más simple (1 query en vez de múltiples cálculos)

ALTERNATIVA (Cálculo manual):
    # Si se prefiere no depender del trigger
    costos = self.db.fetch_one(
        "SELECT 
            COALESCE(SUM(total_a_cobrar), 0),
            COALESCE(SUM(costo_total_repuestos), 0), 
            COALESCE(SUM(costo_total_servicios), 0)
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? 
           AND fecha_cierre IS NOT NULL",
        (fecha_inicio, fecha_fin)
    )
    total_cobrado = costos[0]
    costo_repuestos = costos[1]
    costo_servicios = costos[2]
    
    ganancia_bruta = total_cobrado - costo_repuestos - costo_servicios - total_mo

RECOMENDACIÓN FINAL: Usar trigger (primera opción)
    • Razón: Consistencia con resto del sistema
    • Razón: Triggers ya validados en SEMANA 1
    • Razón: Menos código Python, más confiable


═══════════════════════════════════════════════════════════════════════════════
                        MATRIZ DE RIESGO
═══════════════════════════════════════════════════════════════════════════════

┌────────────────────────┬─────────────┬────────────┬──────────────────────┐
│ Cambio                 │ Archivo     │ Criticidad │ Tipo de Riesgo       │
├────────────────────────┼─────────────┼────────────┼──────────────────────┤
│ fecha→fecha_entrada    │ reportes    │ ALTA       │ Queries fallan       │
│ presup→presup_inicial  │ reportes    │ ALTA       │ Queries fallan       │
│ ganancia_bruta (fix)   │ reportes    │ CRÍTICA    │ Datos incorrectos    │
│ rut→cedula (si aplica) │ logic/imp   │ BLOQUEANTE │ Clientes no funcionan│
└────────────────────────┴─────────────┴────────────┴──────────────────────┘

PRIORIDAD DE APLICACIÓN:
1. ⚠️ VERIFICAR esquema clientes (¿rut o cedula?)
2. ⚠️⚠️⚠️ Corregir ganancia_bruta (CRÍTICO - datos erróneos)
3. ⚠️⚠️ Renombres en reportes_avanzados_logic.py (ALTA - queries fallan)
4. ⚠️ Renombres en logic.py/importador si aplica (BLOQUEANTE si cambió)


═══════════════════════════════════════════════════════════════════════════════
                    PLAN DE IMPLEMENTACIÓN
═══════════════════════════════════════════════════════════════════════════════

PASO 1: Verificar esquema de tabla clientes
─────────────────────────────────────────────────────────────────────────────
Método: Leer database_schema_optimized.sql
Buscar: CREATE TABLE clientes
Verificar: ¿Campo "rut" o "cedula"?

PASO 2: Aplicar cambios en reportes_avanzados_logic.py
─────────────────────────────────────────────────────────────────────────────
Archivos: 1
Queries afectadas: 4
Cambios: 8 ocurrencias (4x fecha, 4x presupuesto)

Queries a modificar:
    1. Línea 26:  OBTENER_REPORTE_VENTAS_PERÍODO()
    2. Línea 62:  OBTENER_REPORTE_VENTAS_DIARIAS()
    3. Línea 116: OBTENER_REPORTE_GANANCIAS()
    4. Línea 225: OBTENER_CLIENTES_TOP()

Método: multi_replace_string_in_file (batch operation)

PASO 3: Corregir cálculo de ganancia_bruta (CRÍTICO)
─────────────────────────────────────────────────────────────────────────────
Ubicación: Líneas 140-142
Cambio: Reemplazar cálculo manual por query a utilidad_bruta de trigger

ANTES:
    ganancia_bruta = total_ventas - total_mo

DESPUÉS:
    utilidad = self.db.fetch_one(
        "SELECT COALESCE(SUM(utilidad_bruta), 0) 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? AND fecha_cierre IS NOT NULL",
        (fecha_inicio, fecha_fin)
    )
    ganancia_bruta = utilidad[0]

Método: replace_string_in_file (cambio específico)

PASO 4: Aplicar cambios en logic.py/importador (SI APLICA)
─────────────────────────────────────────────────────────────────────────────
Condición: SOLO si columna clientes cambió de "rut" a "cedula"
Archivos: 2 (logic.py, importador_logic.py)
Cambios: 9 ocurrencias (4 logic + 5 importador)

Método: multi_replace_string_in_file (batch operation) SI APLICA

PASO 5: Validación post-cambios
─────────────────────────────────────────────────────────────────────────────
Tests recomendados:
    1. Generar reporte de ventas → Verificar que carga datos
    2. Generar reporte de ganancias → Verificar utilidad_bruta correcta
    3. Exportar a Excel → Verificar que exporta correctamente
    4. Buscar cliente (si cambió rut) → Verificar que encuentra
    5. Importar clientes (si cambió rut) → Verificar que importa


═══════════════════════════════════════════════════════════════════════════════
                        CÓDIGO ANTES/DESPUÉS
═══════════════════════════════════════════════════════════════════════════════

EJEMPLO 1: OBTENER_REPORTE_VENTAS_PERÍODO()
─────────────────────────────────────────────────────────────────────────────

ANTES:
    ventas = self.db.fetch_all(
        "SELECT id, cliente_id, presupuesto, abono, estado, fecha 
         FROM ordenes 
         WHERE fecha BETWEEN ? AND ? 
         ORDER BY fecha DESC",
        (fecha_inicio, fecha_fin)
    )
    
    total_ventas = sum(v[2] for v in ventas)  # presupuesto

DESPUÉS:
    ventas = self.db.fetch_all(
        "SELECT id, cliente_id, presupuesto_inicial, abono, estado, fecha_entrada 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? 
         ORDER BY fecha_entrada DESC",
        (fecha_inicio, fecha_fin)
    )
    
    total_ventas = sum(v[2] for v in ventas)  # presupuesto_inicial (mismo índice)

JUSTIFICACIÓN:
    • fecha → fecha_entrada: Campo renombrado (representa fecha de ingreso)
    • presupuesto → presupuesto_inicial: Presupuesto estimado al ingresar orden
    • Índice v[2] no cambia: Sigue siendo el tercer campo del SELECT
    • Línea 30 NO requiere modificación (v[2] sigue siendo válido)


EJEMPLO 2: OBTENER_REPORTE_GANANCIAS() - Cálculo de ganancia_bruta
─────────────────────────────────────────────────────────────────────────────

ANTES (INCORRECTO):
    # Ventas
    ventas = self.db.fetch_one(
        "SELECT SUM(presupuesto) as total FROM ordenes WHERE fecha BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )
    total_ventas = ventas[0] if ventas[0] else 0
    
    # Costos de servicios (mano de obra)
    costos_mo = self.db.fetch_one(
        "SELECT SUM(comision) as total FROM comisiones WHERE fecha BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )
    total_mo = costos_mo[0] if costos_mo[0] else 0
    
    # Cálculo INCORRECTO (solo resta mano de obra)
    ganancia_bruta = total_ventas - total_mo

DESPUÉS (CORRECTO):
    # Ventas (actualizado)
    ventas = self.db.fetch_one(
        "SELECT SUM(presupuesto_inicial) as total FROM ordenes WHERE fecha_entrada BETWEEN ? AND ?",
        (fecha_inicio, fecha_fin)
    )
    total_ventas = ventas[0] if ventas[0] else 0
    
    # Utilidad bruta calculada por trigger (incluye TODOS los costos)
    utilidad = self.db.fetch_one(
        "SELECT COALESCE(SUM(utilidad_bruta), 0) as total 
         FROM ordenes 
         WHERE fecha_entrada BETWEEN ? AND ? AND fecha_cierre IS NOT NULL",
        (fecha_inicio, fecha_fin)
    )
    ganancia_bruta = utilidad[0]
    
    # Nota: Ya NO se necesita calcular manualmente (trigger lo hace)
    # Trigger resta: costo_total_repuestos + costo_total_servicios

JUSTIFICACIÓN:
    • Trigger calcula: utilidad_bruta = total_a_cobrar - costos_repuestos - costos_servicios
    • Más preciso: Incluye TODOS los costos, no solo mano de obra
    • Consistente: Usa misma fórmula que triggers automáticos
    • Filtro agregado: AND fecha_cierre IS NOT NULL (solo órdenes cerradas)


EJEMPLO 3: OBTENER_CLIENTES_TOP()
─────────────────────────────────────────────────────────────────────────────

ANTES:
    clientes = self.db.fetch_all(
        "SELECT c.nombre, COUNT(o.id) as cantidad, SUM(o.presupuesto) as total 
         FROM clientes c 
         LEFT JOIN ordenes o ON c.id = o.cliente_id 
         GROUP BY c.id 
         ORDER BY total DESC 
         LIMIT ?",
        (límite,)
    )

DESPUÉS:
    clientes = self.db.fetch_all(
        "SELECT c.nombre, COUNT(o.id) as cantidad, SUM(o.presupuesto_inicial) as total 
         FROM clientes c 
         LEFT JOIN ordenes o ON c.id = o.cliente_id 
         GROUP BY c.id 
         ORDER BY total DESC 
         LIMIT ?",
        (límite,)
    )

JUSTIFICACIÓN:
    • o.presupuesto → o.presupuesto_inicial: Campo renombrado en tabla ordenes
    • LEFT JOIN preservado: Cliente puede no tener órdenes
    • SUM(o.presupuesto_inicial): Suma total gastado por cliente
    • Alias "as total" preservado: Línea 233 accede a cliente[2] sin cambios


═══════════════════════════════════════════════════════════════════════════════
                        TESTING REQUERIDO
═══════════════════════════════════════════════════════════════════════════════

TESTS CRÍTICOS - REPORTES:
─────────────────────────────────────────────────────────────────────────────
1. Test: Reporte de ventas período
   Ejecutar: OBTENER_REPORTE_VENTAS_PERÍODO("2025-01-01", "2025-12-31")
   Verificar: Devuelve dict con total_ventas, cantidad_ordenes
   Validar: No arroja error "no such column: fecha" o "presupuesto"

2. Test: Reporte de ventas diarias
   Ejecutar: OBTENER_REPORTE_VENTAS_DIARIAS("2025-12-01", "2025-12-31")
   Verificar: Devuelve array de ventas por día
   Validar: Fechas en formato correcto

3. Test: Reporte de ganancias (CRÍTICO)
   Ejecutar: OBTENER_REPORTE_GANANCIAS("2025-12-01", "2025-12-31")
   Verificar: ganancia_bruta menor que total_ventas
   Validar: ganancia_bruta NO es (total_ventas - solo_comisiones)
   Validar: Usar calculadora manual: ¿coincide con suma de utilidad_bruta?

4. Test: Clientes TOP
   Ejecutar: OBTENER_CLIENTES_TOP(10)
   Verificar: Devuelve array de 10 clientes
   Validar: Ordenados por gasto_total descendente

TESTS COMPLEMENTARIOS - CLIENTES (SI cambió rut):
─────────────────────────────────────────────────────────────────────────────
1. Test: Buscar cliente
   Ejecutar: logic.clientes.OBTENER_CLIENTE("12345678-9")
   Verificar: Devuelve datos del cliente
   Validar: No arroja error "no such column: rut"

2. Test: Agregar cliente
   Ejecutar: logic.clientes.AGREGAR_CLIENTE("98765432-1", "JUAN PEREZ", "912345678", "juan@mail.com")
   Verificar: Cliente se crea correctamente
   Validar: Campo cedula guardado en BD

3. Test: Importar clientes Excel
   Acción: Importar archivo con columna RUT/CÉDULA
   Verificar: Importación exitosa
   Validar: Clientes en tabla con cedula correcta


═══════════════════════════════════════════════════════════════════════════════
                        PREGUNTA PARA AUTORIZACIÓN
═══════════════════════════════════════════════════════════════════════════════

PREGUNTA 1 (CRÍTICA): ¿La columna en tabla "clientes" se llama "rut" o "cedula"?
─────────────────────────────────────────────────────────────────────────────

Si responde "rut":
    → SEMANA 3 aplica 8 cambios (solo reportes_avanzados_logic.py)
    → logic.py y importador_logic.py NO SE TOCAN

Si responde "cedula":
    → SEMANA 3 aplica 17 cambios (reportes + logic + importador)
    → Búsqueda y gestión de clientes afectada

PREGUNTA 2: ¿Autoriza corrección de cálculo de ganancia_bruta?
─────────────────────────────────────────────────────────────────────────────

Problema: Cálculo actual INFLA ganancias (solo resta mano de obra)
Solución: Usar utilidad_bruta calculada por trigger (incluye todos los costos)

Si autoriza:
    → Reportes financieros mostrarán ganancias REALES
    → Consistente con triggers de BD

Si no autoriza:
    → Reportes seguirán mostrando ganancias infladas
    → Decisiones gerenciales basadas en datos incorrectos


═══════════════════════════════════════════════════════════════════════════════
                        RESUMEN FINAL
═══════════════════════════════════════════════════════════════════════════════

ARCHIVOS A MODIFICAR: 1 confirmado + 2 condicionales
    • reportes_avanzados_logic.py (8 cambios + 1 mejora crítica) ✅ CONFIRMADO
    • logic.py (4 cambios) ⏸️ CONDICIONAL (si rut→cedula)
    • importador_logic.py (5 cambios) ⏸️ CONDICIONAL (si rut→cedula)

CAMBIOS TOTALES: 9 confirmados + 9 condicionales = 18 máximo

CRITICIDAD: ⚠️⚠️⚠️ ALTA + CRÍTICA
    • reportes_avanzados_logic.py: ALTA (queries fallan) + CRÍTICA (ganancia_bruta incorrecta)
    • logic.py/importador: BLOQUEANTE si aplica (clientes no funcionan)

TIEMPO ESTIMADO: 15 minutos
    • Aplicación de cambios: 10 min
    • Testing reportes: 5 min

COMPATIBILIDAD: ✅ SIN BREAKING CHANGES EN REPORTES
    • Formato de salida preservado (diccionarios con mismas keys)
    • Índices de tuplas no cambian
    • UI de reportes funciona sin modificación

PREREQUISITOS: ✅ CUMPLIDOS
    • SEMANA 1 completada (tabla ordenes consolidada)
    • SEMANA 2 completada (predicciones actualizadas)
    • Triggers activos (utilidad_bruta calculada automáticamente)

SIGUIENTE FASE: SEMANA 4 (10 cambios BAJA prioridad)
    • Optimizaciones menores
    • Limpieza de código legacy


═══════════════════════════════════════════════════════════════════════════════
                        AUTORIZACIÓN REQUERIDA
═══════════════════════════════════════════════════════════════════════════════

PREGUNTAS ANTES DE PROCEDER:

1. ¿La columna en tabla "clientes" se llama "rut" o "cedula"?
   (Respuesta determinará si se modifican logic.py e importador_logic.py)

2. ¿Autoriza corrección del cálculo de ganancia_bruta para usar utilidad_bruta de trigger?
   (Recomendado: SÍ - corrige reportes financieros inflados)

3. ¿Autoriza aplicación de 8 cambios en reportes_avanzados_logic.py?
   (fecha→fecha_entrada, presupuesto→presupuesto_inicial)

SI AUTORIZA:
    1. Responderé preguntas 1 y 2
    2. Aplicaré cambios confirmados + condicionales según respuesta
    3. Generaré documento CAMBIOS_SEMANA_3_APLICADOS.txt
    4. Presentaré resumen de cambios aplicados

SI NO AUTORIZA:
    Indique qué requiere ajustes o aclaraciones adicionales.


═══════════════════════════════════════════════════════════════════════════════
                        FIN DEL ANÁLISIS DE IMPACTO
═══════════════════════════════════════════════════════════════════════════════
